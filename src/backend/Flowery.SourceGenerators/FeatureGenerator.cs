using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Flowery.SourceGenerators;

[Generator]
public class FeatureGenerator : IIncrementalGenerator
{
    private const string FeatureInterfaceName = "Flowery.WebApi.Shared.Features.IFeature";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<INamedTypeSymbol> featureClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is ClassDeclarationSyntax { BaseList: not null },
                transform: static (ctx, _) =>
                {
                    SemanticModel semanticModel = ctx.SemanticModel;
                    ClassDeclarationSyntax classDeclaration = (ClassDeclarationSyntax)ctx.Node;

                    if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
                    {
                        return null;
                    }

                    foreach (var implementedInterface in classSymbol.AllInterfaces)
                    {
                        if (implementedInterface.ToDisplayString() == FeatureInterfaceName)
                        {
                            return classSymbol;
                        }
                    }

                    return null;
                })
            .Where(static symbol => symbol is not null)!;

        IncrementalValueProvider<ImmutableArray<INamedTypeSymbol>> collectedFeatures = featureClasses.Collect();

        context.RegisterSourceOutput(collectedFeatures, static (spc, source) =>
        {
            if (source.IsDefaultOrEmpty)
            {
                return;
            }

            List<string> featureClassNames = source.Select(s => s.ToDisplayString()).ToList();
            string sourceCode = GenerateFeatureExtensions(featureClassNames);
            spc.AddSource("FeatureExtensions.g.cs", sourceCode);
        });
    }

    private static string GenerateFeatureExtensions(List<string> featureClassNames)
    {
        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("using Microsoft.AspNetCore.Builder;");
        builder.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        builder.AppendLine();

        foreach (var featureName in featureClassNames.Select(f => f.Substring(0, f.LastIndexOf('.'))).Distinct())
        {
            builder.AppendLine($"using {featureName};");
        }

        builder.AppendLine();

        builder.AppendLine("namespace Flowery.WebApi.Shared.Extensions;");
        builder.AppendLine();
        builder.AppendLine("public static class FeatureExtensions");
        builder.AppendLine("{");

        builder.AppendLine("    public static IServiceCollection AddFeatures(this IServiceCollection services)");
        builder.AppendLine("    {");
        foreach (var className in featureClassNames)
        {
            builder.AppendLine($"        {className}.Register(services);");
        }

        builder.AppendLine("        return services;");
        builder.AppendLine("    }");
        builder.AppendLine();

        builder.AppendLine("    public static IEndpointRouteBuilder MapFeatures(this IEndpointRouteBuilder app)");
        builder.AppendLine("    {");

        foreach (var className in featureClassNames)
        {
            builder.AppendLine($"        {className}.MapEndpoint(app);");
        }

        builder.AppendLine("        return app;");
        builder.AppendLine("    }");

        builder.AppendLine("}");

        return builder.ToString();
    }
}